import com.amazonaws.services.glue.ChoiceOption
import com.amazonaws.services.glue.DynamicRecord
import com.amazonaws.services.glue.GlueContext
import com.amazonaws.services.glue.MappingSpec
import com.amazonaws.services.glue.ResolveSpec
import com.amazonaws.services.glue.errors.CallSite
import com.amazonaws.services.glue.types.StringNode
import com.amazonaws.services.glue.util.GlueArgParser
import com.amazonaws.services.glue.util.Job
import com.amazonaws.services.glue.util.JsonOptions
import org.apache.spark.SparkContext
import scala.collection.JavaConverters._

// Tweaked from a script generated by Glue.
object GlueApp {
  def main(sysArgs: Array[String]) {
    val spark: SparkContext = new SparkContext()
    val glueContext: GlueContext = new GlueContext(spark)
    // @params: [JOB_NAME]
    val args = GlueArgParser.getResolvedOptions(
      sysArgs,
      Seq(
        "JOB_NAME",
        "metadata_database",
        "input_table_name",
        "output_path"
      ).toArray
    )
    val database = args("metadata_database")
    val inputTableName = args("input_table_name")
    val outputPath = args("output_path")
    Job.init(args("JOB_NAME"), glueContext, args.asJava)
    // @type: DataSource
    // @args: [database = "$metadata_database", table_name = "$input_table_name", transformation_ctx = "datasource0"]
    // @return: datasource0
    // @inputs: []
    val datasource0 = glueContext.getCatalogSource(
      database=database,
      tableName=inputTableName,
      redshiftTmpDir="",
      transformationContext="datasource0"
    ).getDynamicFrame()
    // @type: ApplyMapping
    // @args: [mapping = [("cord_uid", "string", "cord_uid", "string"), ("sha", "string", "paper_id", "string"), ("source_x", "string", "source_x", "string"), ("title", "string", "title", "string"), ("doi", "string", "doi", "string"), ("pmcid", "string", "pmcid", "string"), ("pubmed_id", "string", "pubmed_id", "string"), ("license", "string", "license", "string"), ("abstract", "string", "abstract", "string"), ("publish_time", "string", "publish_time", "string"), ("authors", "string", "authors", "string"), ("journal", "string", "journal", "string"), ("microsoft academic paper id", "string", "microsoft academic paper id", "string"), ("who #covidence", "string", "who #covidence", "string"), ("has_full_text", "boolean", "has_full_text", "boolean"), ("full_text_file", "string", "full_text_file", "string"), ("url", "string", "url", "string")], transformation_ctx = "applymapping1"]
    // @return: applymapping1
    // @inputs: [frame = datasource0]
    val applymapping1 = datasource0.applyMapping(
      mappings=Seq(("cord_uid", "string", "cord_uid", "string"), ("sha", "string", "paper_id", "string"), ("source_x", "string", "source_x", "string"), ("title", "string", "title", "string"), ("doi", "string", "doi", "string"), ("pmcid", "string", "pmcid", "string"), ("pubmed_id", "string", "pubmed_id", "string"), ("license", "string", "license", "string"), ("abstract", "string", "abstract", "string"), ("publish_time", "string", "publish_time", "string"), ("authors", "string", "authors", "string"), ("journal", "string", "journal", "string"), ("microsoft academic paper id", "string", "microsoft academic paper id", "string"), ("who #covidence", "string", "who #covidence", "string"), ("has_full_text", "boolean", "has_full_text", "boolean"), ("full_text_file", "string", "full_text_file", "string"), ("url", "string", "url", "string")),
      caseSensitive=false,
      transformationContext="applymapping1")
    // @type: ResolveChoice
    // @args: [choice = "make_struct", transformation_ctx = "resolvechoice2"]
    // @return: resolvechoice2
    // @inputs: [frame = applymapping1]
    val resolvechoice2 = applymapping1.resolveChoice(
      choiceOption=Some(ChoiceOption("make_struct")),
      transformationContext="resolvechoice2")
    // @type: Filter
    // @args: [f = has_paper_id, transformation_ctx = "dropnullpaperid3"]
    // @return: dropnullpaperid3
    // @inputs: [frame = resolvechoice2]
    def has_paper_id(r: DynamicRecord) = r.getField("paper_id").isDefined
    val dropnullpaperid3 = resolvechoice2.filter(
      f=has_paper_id,
      transformationContext="dropnullpaperid3")
    // @type: Map
    // @args: [f = make_partition_id, transformation_ctx = "withpartitionid4"]
    // @return withpartitionid4
    // @inputs: [frame = dropnullpaperid2]
    def make_partition_id(r: DynamicRecord) = {
      val paperId = r.getField("paper_id").get.asInstanceOf[String]
      r.addField("partition_id", StringNode(paperId.substring(0, 2)))
      r
    }
    val withpartitionid4 = dropnullpaperid3.map(
      f=make_partition_id,
      transformationContext="withpartitionid4")
    // @type: DataSink
    // @args: [connection_type = "s3", connection_options = {"path": "$output_path"}, format = "parquet", transformation_ctx = "datasink4"]
    // @return: datasink4
    // @inputs: [frame = dropnullpaperid3]
    val datasink4 = glueContext.getSinkWithFormat(
      connectionType="s3",
      options=JsonOptions(s"""{"path": "$outputPath", "partitionKeys": ["partition_id"] }"""),
      transformationContext="datasink4",
      format="parquet"
    ).writeDynamicFrame(withpartitionid4)
    Job.commit()
  }
}
